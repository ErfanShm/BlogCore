# ğŸ“„ BlogCore

Empowering content creators with AI-driven blog generation and SEO optimization.

Welcome to the **BlogCore** repository! Based on the codebase analysis, this project appears to implement a robust Flask web application designed to automate and enhance the blog content creation process, leveraging advanced AI and Google services.

-   **Flask Web Application:** Provides the web interface and handles user requests for content generation.
-   **AI Content Generation Engine:** Integrates with AvvalAI to generate high-quality, SEO-optimized blog posts and content briefs in Persian.
-   **Google Drive Integration:** Facilitates automatic upload of generated `.docx` articles to Google Drive.
-   **Google Search Integration:** Fetches real-time competitor data to inform content strategy.
-   **Document Conversion:** Converts Markdown content into professional Word documents with specific formatting.
-   **Keyword Suggestion:** Integrates with KWRank API to provide relevant keyword suggestions.

This project solves the challenge of rapidly producing comprehensive, search-engine-friendly blog content by streamlining the entire workflow from keyword analysis to final document creation and storage. It primarily uses Python with the Flask framework, along with various libraries for AI communication, document manipulation, and Google API interactions.

---

## âœ¨ Overview

BlogCore serves as an intelligent assistant for content strategists and and writers, automating several time-consuming aspects of blog post creation. It emphasizes SEO best practices, rich content generation, and seamless integration with cloud services.

Based on the analysis, key features appear to include:

*   **AI-Powered Heading Suggestion:** Automatically generates optimized H2 and H3 headings based on a primary keyword, functioning as an SEO strategist.
*   **Comprehensive Blog Post Generation:** Crafts detailed, human-like, and SEO-compliant blog posts in Persian, adhering to specified word counts, tones, audiences, and custom structures.
*   **Competitor Analysis Integration:** Utilizes Google Custom Search to retrieve top-ranking competitor URLs and titles, injecting this data into the AI's prompt for richer content context.
*   **Markdown to DOCX Conversion:** Converts the AI-generated Markdown content into a professionally formatted Microsoft Word document (.docx) with right-to-left (RTL) support and Vazirmatn font.
*   **Google Drive Automatic Upload:** Automatically uploads the generated .docx files to a specified Google Drive folder, providing easy access and organization.
*   **Content Brief Generation:** Creates detailed content briefs, including search intent, target audience, catchy titles, content structure, key elements, keywords (primary/secondary), SEO tips, FAQs, and CTA suggestions, all tailored by AI.
*   **Keyword Suggestion Tool:** Integrates with the KWRank API to provide a list of suggested keywords based on a primary keyword, aiding in SEO research.

The project's primary purpose is to empower users to efficiently create high-quality, SEO-optimized blog content, significantly reducing manual effort and improving content relevance.

---

## ğŸ—‚ï¸ File Structure

```
.
â”œâ”€â”€ .env                       # Environment variables (manually filled by user after template creation)
â”œâ”€â”€ .env.tmp                   # Template for environment variables (used by setup.bat)
â”œâ”€â”€ .gitignore                 # Specifies files/directories to be ignored by Git
â”œâ”€â”€ pyproject.toml             # Project metadata and dependencies (managed by uv)
â”œâ”€â”€ uv.lock                    # Locked dependency versions for reproducible builds (generated by uv)
â”œâ”€â”€ README.md                  # Project overview and documentation
â”œâ”€â”€ setup.bat                  # Automated setup script for Windows
â”œâ”€â”€ run.py                     # Main entry point to run the Flask application
â”œâ”€â”€ app/                       # Main application package
â”‚   â”œâ”€â”€ __init__.py            # Initializes the Flask app and registers blueprints
â”‚   â”œâ”€â”€ routes.py              # Defines all web routes/endpoints
â”‚   â”œâ”€â”€ services.py            # Contains business logic and helper functions (e.g., AI calls, Google API integrations)
â”‚   â”œâ”€â”€ llm_clients.py         # Handles OpenAI client initialization and function schema
â”‚   â”œâ”€â”€ utils.py               # Utility functions (e.g., prompt loading)
â”‚   â”œâ”€â”€ prompts/               # Directory for prompt templates
â”‚   â”‚   â”œâ”€â”€ generate_article_prompt.txt
â”‚   â”‚   â”œâ”€â”€ generate_brief_prompt.txt
â”‚   â”‚   â””â”€â”€ suggest_headings_prompt.txt
â”‚   â”œâ”€â”€ templates/             # Jinja2 HTML templates for rendering web pages
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ result.html
â”‚   â”‚   â”œâ”€â”€ brief.html
â”‚   â”‚   â”œâ”€â”€ brief_result.html
â”‚   â”‚   â””â”€â”€ keyword_suggester.html # New: Template for keyword suggestion tool
â”‚   â””â”€â”€ static/                # Static assets like CSS, JavaScript, images
â”‚       â”œâ”€â”€ css/
â”‚       â””â”€â”€ img/
â”œâ”€â”€ tests/                     # Unit and integration tests (placeholder)
â””â”€â”€ data/                      # Directory for example data, temporary outputs
    â””â”€â”€ generated_docs/        # Where generated .docx files are stored
```

## ğŸš€ Features

*   **AI-Powered Heading Suggestion (`/suggest-headings`):**
    *   Takes a keyword and leverages the AvvalAI model (Gemini 1.5 Pro) to act as a senior SEO strategist.
    *   Generates a list of optimized H2 and H3 headings suitable for a blog post on the given keyword.
    *   Returns headings in a JSON format for easy integration into the content creation workflow.

*   **Comprehensive Blog Post Generation (`/generate`):**
    *   Gathers various inputs: article title, primary keyword, secondary keywords, desired word count, target audience, specific headings (or auto-generate), and tone.
    *   Performs real-time Google Search for the primary keyword to identify top-5 competitor sites.
    *   Constructs a highly detailed prompt for the AvvalAI model, incorporating SEO principles (EEAT), competitor insights, and explicit content structure/quality instructions.
    *   Receives a JSON response from the AI containing meta descriptions, the full blog post in Markdown, and image prompts.
    *   **Workflow:**
        1.  Collect user inputs (title, keywords, word count, audience, headings, tone, temperature).
        2.  Fetch top-5 competitor URLs and titles using Google Custom Search API.
        3.  Prepare competitor information for AI prompt injection.
        4.  Define content structure based on user-provided headings or AI auto-generation.
        5.  Construct a comprehensive, multi-part prompt for AvvalAI, acting as a world-class Persian content writer and SEO strategist.
        6.  Call AvvalAI ChatCompletion endpoint, expecting a JSON response with article content, meta descriptions, and image prompts.
        7.  Parse the AI's JSON response, extracting content.
        8.  Convert the generated Markdown blog post to HTML for web display.
        9.  Convert the Markdown content to a `.docx` file using `python-docx`, ensuring RTL formatting and Vazirmatn font.
        10. Upload the generated `.docx` file to Google Drive.
        11. Calculate word count for the generated article.
        12. Renders a results page displaying generated content, meta descriptions, image prompts, word count, and a link to the Google Doc.

*   **Content Brief Generation (`/generate-brief`):**
    *   Takes a primary keyword and generates a comprehensive content brief.
    *   The brief includes: search intent, target audience, catchy titles, content structure (H2/H3), key elements to include, primary/secondary keywords, SEO tips, FAQs, and CTA suggestions, all tailored by AI.
    *   Leverages AvvalAI to populate this structured JSON brief, providing a strong foundation for content planning.

*   **Keyword Suggestion Tool (`/keyword_suggester` and `/get-keyword-suggestions`):**
    *   Allows users to input a primary keyword.
    *   Interacts with the KWRank API to fetch a list of related keyword suggestions.
    *   Displays the suggested keywords in a user-friendly list, aiding in SEO research and content planning.

*   **Document Conversion (`create_word_document`):**
    *   Helper function responsible for converting Markdown text into a `.docx` file.
    *   Applies a right-to-left layout, sets Vazirmatn font, and handles various Markdown elements (headings, lists, tables, bold text).

*   **Google Drive Integration (`upload_as_google_doc`):**
    *   Helper function to upload the locally created `.docx` file to a specified Google Drive folder.
    *   Converts the `.docx` to a Google Doc format during upload.
    *   Deletes the local `.docx` file after successful upload.

*   **Google Custom Search (`perform_Google_Search`):**
    *   Integrates with the Google Custom Search JSON API to fetch top search results for a given keyword, providing valuable competitor data to the AI.

### Localization & SEO Prompt Engineering
The prompts sent to AvvalAI are extensively detailed, acting as a "senior SEO strategist" and "world-class Persian content writer." They include instructions for:
*   EEAT principles (Experience, Expertise, Authoritativeness, Trustworthiness).
*   Target audience, tone, and specific word counts.
*   Analysis of competitor content structure and themes.
*   Adherence to custom content structures (headings).
*   SEO-friendly language, natural keyword integration, and readability.
*   Instructions to avoid AI detection patterns, ensuring human-like output.
*   For the brief generation, the AI is prompted to return a very specific JSON structure with detailed SEO and content planning elements in Persian.

---

## ğŸ“‹ Requirements

1.  **Software:**
    *   Python 3.8+ (inferred from `pyproject.toml` `requires-python`)
    *   `uv` (fast Python package installer and resolver) - Install globally: `pip install uv`

2.  **Dependencies:** (Managed via `pyproject.toml` and `uv`)
    The project dependencies are defined in `pyproject.toml`.
    *   `Flask`
    *   `requests`
    *   `markdown`
    *   `python-docx`
    *   `google-api-python-client`
    *   `google-auth-httplib2`
    *   `google-auth-oauthlib`
    *   `python-dotenv`

3.  **Environment Setup:**
    *   **Google Cloud Credentials:** Obtain a Google Cloud service account key file (`credentials.json`) with access to Google Drive API. Place this file in the project root.
    *   **Environment Variables (`.env`):** A `.env` template (`.env.tmp`) will be created by `setup.bat`. You must then manually create and fill your `.env` file based on this template, replacing placeholders with your actual API keys and configuration settings.

    ```env
    FLASK_SECRET_KEY=your_flask_secret_key
    API_KEY=your_openai_api_key
    BASE_URL=https://api.avalapis.ir/v1
    OPENAI_TIMEOUT=90

    # Google API Credentials
    GOOGLE_CREDENTIALS_FILE=credentials.json
    GOOGLE_DRIVE_FOLDER_ID=your_google_drive_folder_id
    API_KEY_GOOGLE=your_google_api_key
    ENGINE_ID_GOOGLE=your_google_search_engine_id

    # KWRank API Credentials
    KWRANK_CLIENT_ID=your_kwrank_client_id
    KWRANK_SECRET_ID=your_kwrank_secret_id
    ```

---

## ğŸ’» Installation & Launch Instructions

1.  **Clone the Repository**
    ```bash
    git clone https://github.com/your-username/BlogCore.git # Replace with your actual repository URL
    cd BlogCore
    ```
2.  **Run the Setup Script (Windows)**
    This script (`setup.bat`) automates the environment setup.
    It will:
    *   Create a `.env.tmp` (if it doesn't exist).
    *   Create a virtual environment (`.venv`) using `uv`.
    *   Install all Python dependencies defined in `pyproject.toml` and lock them (or synchronize with an existing `uv.lock`).

    ```bash
    setup.bat
    ```
    **Important:** After running the script, a `.env.tmp` will be created. You must **manually create a file named `.env`** in the project root and populate it with your actual API keys and Google IDs, using `.env.tmp` as a guide.

3.  **Launch the Application**
    First, activate the virtual environment:
    ```bash
    .venv\Scripts\activate   # On Windows (from project root)
    # For macOS/Linux users, it would be: source .venv/bin/activate
    ```
    Then, run the Flask application:
    ```bash
    python run.py
    ```
    The Flask development server will start, typically accessible at `http://127.0.0.1:5000/`.

---

## ğŸ“ Usage Guide

After launching the application, access it via your web browser (e.g., `http://127.0.0.1:5000/`).

*   **Homepage (`/`):** Provides the main interface for interacting with the blog generation features.
*   **Suggest Headings (`/suggest-headings`):** (Accessed via UI or POST request)
    *   Input a primary keyword.
    *   The system will suggest a list of H2 and H3 headings optimized for SEO.
*   **Generate Blog Post (`/generate`):**
    *   Fill in details like article title, primary/secondary keywords, desired word count, target audience, and content tone.
    *   You can choose to provide your own headings or let the AI auto-generate them.
    *   The application will fetch competitor data, generate the full blog post, convert it to DOCX, and upload it to Google Drive.
    *   The result page will display the generated HTML, meta descriptions, image prompts, word count, and a link to the Google Doc.
*   **Content Brief Page (`/brief`):** Renders a form for generating content briefs.
*   **Generate Content Brief (`/generate-brief`):** (Accessed via UI or POST request)
    *   Input a primary keyword.
    *   The AI will generate a comprehensive content brief in JSON format, covering search intent, audience, titles, structure, keywords, SEO tips, and FAQs.
*   **Keyword Suggester Page (`/keyword_suggester`):**
    *   Navigate to this page from the homepage.
    *   Enter a keyword into the input field and click "Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª" (Get Suggestions).
    *   The page will display a list of suggested keywords from the KWRank API, or an error message if the request fails.

---

## âš™ï¸ Technical Implementation Details

### Core Flask Application Structure
The application uses a standard Flask blueprint structure. `run.py` is the entry point, `app/__init__.py` initializes the Flask app, `app/routes.py` defines the web routes, and `app/services.py` encapsulates the core business logic and API integrations.

### Dependency Management with `uv`
The project leverages `uv` for fast and reliable Python dependency management.
*   Dependencies are declared in `pyproject.toml`.
*   `uv sync` is used to create and synchronize the virtual environment with the exact package versions.

### Document Handling and Conversion
*   **Markdown to DOCX:** The `create_word_document` function (in `app/services.py`) uses the `python-docx` library to convert Markdown text into a `.docx` file. It's specifically configured for Persian language support, including right-to-left (RTL) text alignment and the "Vazirmatn" font. It handles Markdown headings, lists, tables, and inline bold formatting.
*   **Word Count:** The `count_words_fa` helper function uses regex to accurately count Persian and English words.

### Cloud Service Integration
*   **Google Drive Upload:** The `upload_as_google_doc` function (in `app/services.py`) utilizes the `google-api-python-client` to upload `.docx` files to a specified Google Drive folder. It uploads them as Google Docs, ensuring they are accessible and editable in Google Workspace. It also cleans up the local `.docx` file after successful upload.
*   **Google Custom Search:** The `perform_Google_Search` function (in `app/services.py`) integrates with the Google Custom Search JSON API to fetch top search results for a given keyword, providing valuable competitor data to the AI.
*   **KWRank API Integration:** The `get_kwrank_auth_token` and `get_kwrank_keyword_suggestions` functions (in `app/services.py`) handle authentication with the KWRank API and retrieve keyword suggestions, respectively.

### Localization & SEO Prompt Engineering
The prompts sent to AvvalAI are extensively detailed, acting as a "senior SEO strategist" and "world-class Persian content writer." They include instructions for:
*   EEAT principles (Experience, Expertise, Authoritativeness, Trustworthiness).
*   Target audience, tone, and specific word counts.
*   Analysis of competitor content structure and themes.
*   Adherence to custom content structures (headings).
*   SEO-friendly language, natural keyword integration, and readability.
*   Instructions to avoid AI detection patterns, ensuring human-like output.
*   For the brief generation, the AI is prompted to return a very specific JSON structure with detailed SEO and content planning elements in Persian.

---

## ğŸ“ˆ Current Status & Future Plans

### Current Status
*   This project appears to be a functional prototype or a Minimum Viable Product (MVP) for AI-powered blog content generation.
*   Key functionalities such as AI-driven content generation, document conversion, Google Drive integration, and now KWRank keyword suggestion seem complete and operational based on the provided code.
*   The application handles user input via web forms and processes it using Flask routes.

### Future Enhancements
No explicit TODO comments, placeholder functions, or issue templates were found in the analyzed codebase to suggest specific future plans. Therefore, future enhancements are unclear from the current codebase. Potential areas for future development *could* include:
1.  User authentication and management.
2.  Database integration for storing generated content and briefs.
3.  More advanced content editing and review features within the application.
4.  Integration with other content management systems (CMS).
5.  Expansion to other languages beyond Persian.

---

## ğŸ™Œ Acknowledgments

Acknowledgments were not explicitly identified within the codebase comments or obvious dependency files.

---

## ğŸ“œ License

No `LICENSE` file was found in the repository root. The license for this project is currently unclear. 
